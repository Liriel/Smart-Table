{"version":3,"sources":["smart-table.min.js"],"names":["ng","undefined","module","run","$templateCache","put","constant","pagination","template","itemsByPage","displayedPages","search","delay","inputEvent","select","mode","selectedClass","sort","ascentClass","descentClass","descendingFirst","skipNatural","pipe","controller","$scope","$parse","$filter","$attrs","copyRefs","src","concat","updateSafeCopy","safeCopy","safeGetter","pipeAfterSafeCopy","ctrl","deepDelete","object","path","indexOf","partials","split","key","pop","parentPath","join","parentObject","Object","keys","length","filtered","lastSelected","propertyName","stTable","displayGetter","displaySetter","assign","orderBy","filter","tableState","start","totalItemCount","this","stSafeSrc","$watch","safeSrc","newValue","oldValue","sortBy","predicate","reverse","isFunction","functionName","name","input","predicateObject","prop","isString","trim","output","number","numberOfPages","Math","ceil","slice","parseInt","row","rows","index","isSelected","getFilteredCollection","setFilterFunction","filterName","setSortFunction","sortFunctionName","preventPipeOnWatch","directive","restrict","link","scope","element","attr","stSetFilter","stSetSort","stConfig","$timeout","require","func","getter","isArray","stSort","bind","promise","cancel","throttle","sortDefault","classAscent","stClassAscent","classDescent","stClassDescent","stateClasses","stSkipNatural","stDescendingFirst","stDelay","stSortDefault","$eval","$apply","removeClass","addClass","rowsSelected","enabled","stSelectMode","push","splice","angular"],"mappings":"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","file":"smart-table.min.js","sourcesContent":["(function (ng, undefined){\n    'use strict';\n\nng.module('smart-table', []).run(['$templateCache', function ($templateCache) {\n    $templateCache.put('template/smart-table/pagination.html',\n        '<nav ng-if=\"numPages && pages.length >= 2\"><ul class=\"pagination\">' +\n        '<li ng-repeat=\"page in pages\" ng-class=\"{active: page==currentPage}\"><a href=\"javascript: void(0);\" ng-click=\"selectPage(page)\">{{page}}</a></li>' +\n        '</ul></nav>');\n}]);\n\n\nng.module('smart-table')\n  .constant('stConfig', {\n    pagination: {\n      template: 'template/smart-table/pagination.html',\n      itemsByPage: 10,\n      displayedPages: 5\n    },\n    search: {\n      delay: 400, // ms\n      inputEvent: 'input'\n    },\n    select: {\n      mode: 'single',\n      selectedClass: 'st-selected'\n    },\n    sort: {\n      ascentClass: 'st-sort-ascent',\n      descentClass: 'st-sort-descent',\n      descendingFirst: false,\n      skipNatural: false,\n      delay:300\n    },\n    pipe: {\n      delay: 100 //ms\n    }\n  });\nng.module('smart-table')\n  .controller('stTableController', ['$scope', '$parse', '$filter', '$attrs', function StTableController ($scope, $parse, $filter, $attrs) {\n    var propertyName = $attrs.stTable;\n    var displayGetter = $parse(propertyName);\n    var displaySetter = displayGetter.assign;\n    var safeGetter;\n    var orderBy = $filter('orderBy');\n    var filter = $filter('filter');\n    var safeCopy = copyRefs(displayGetter($scope));\n    var tableState = {\n      sort: {},\n      search: {},\n      pagination: {\n        start: 0,\n        totalItemCount: 0\n      }\n    };\n    var filtered;\n    var pipeAfterSafeCopy = true;\n    var ctrl = this;\n    var lastSelected;\n\n    function copyRefs (src) {\n      return src ? [].concat(src) : [];\n    }\n\n    function updateSafeCopy () {\n      safeCopy = copyRefs(safeGetter($scope));\n      if (pipeAfterSafeCopy === true) {\n        ctrl.pipe();\n      }\n    }\n\n    function deepDelete (object, path) {\n      if (path.indexOf('.') != -1) {\n        var partials = path.split('.');\n        var key = partials.pop();\n        var parentPath = partials.join('.');\n        var parentObject = $parse(parentPath)(object)\n        delete parentObject[key];\n        if (Object.keys(parentObject).length == 0) {\n          deepDelete(object, parentPath);\n        }\n      } else {\n        delete object[path];\n      }\n    }\n\n    if ($attrs.stSafeSrc) {\n      safeGetter = $parse($attrs.stSafeSrc);\n      $scope.$watch(function () {\n        var safeSrc = safeGetter($scope);\n        return safeSrc && safeSrc.length ? safeSrc[0] : undefined;\n      }, function (newValue, oldValue) {\n        if (newValue !== oldValue) {\n          updateSafeCopy();\n        }\n      });\n      $scope.$watch(function () {\n        var safeSrc = safeGetter($scope);\n        return safeSrc ? safeSrc.length : 0;\n      }, function (newValue, oldValue) {\n        if (newValue !== safeCopy.length) {\n          updateSafeCopy();\n        }\n      });\n      $scope.$watch(function () {\n        return safeGetter($scope);\n      }, function (newValue, oldValue) {\n        if (newValue !== oldValue) {\n          tableState.pagination.start = 0;\n          updateSafeCopy();\n        }\n      });\n    }\n\n    /**\n     * sort the rows\n     * @param {Function | String} predicate - function or string which will be used as predicate for the sorting\n     * @param [reverse] - if you want to reverse the order\n     */\n    this.sortBy = function sortBy (predicate, reverse) {\n      tableState.sort.predicate = predicate;\n      tableState.sort.reverse = reverse === true;\n\n      if (ng.isFunction(predicate)) {\n        tableState.sort.functionName = predicate.name;\n      } else {\n        delete tableState.sort.functionName;\n      }\n\n      tableState.pagination.start = 0;\n      return this.pipe();\n    };\n\n    /**\n     * search matching rows\n     * @param {String} input - the input string\n     * @param {String} [predicate] - the property name against you want to check the match, otherwise it will search on all properties\n     */\n    this.search = function search (input, predicate) {\n      var predicateObject = tableState.search.predicateObject || {};\n      var prop = predicate ? predicate : '$';\n\n      input = ng.isString(input) ? input.trim() : input;\n      $parse(prop).assign(predicateObject, input);\n      // to avoid to filter out null value\n      if (!input) {\n        deepDelete(predicateObject, prop);\n      }\n      tableState.search.predicateObject = predicateObject;\n      tableState.pagination.start = 0;\n      return this.pipe();\n    };\n\n    /**\n     * this will chain the operations of sorting and filtering based on the current table state (sort options, filtering, ect)\n     */\n    this.pipe = function pipe () {\n      var pagination = tableState.pagination;\n      var output;\n      filtered = tableState.search.predicateObject ? filter(safeCopy, tableState.search.predicateObject) : safeCopy;\n      if (tableState.sort.predicate) {\n        filtered = orderBy(filtered, tableState.sort.predicate, tableState.sort.reverse);\n      }\n      pagination.totalItemCount = filtered.length;\n      if (pagination.number !== undefined) {\n        pagination.numberOfPages = filtered.length > 0 ? Math.ceil(filtered.length / pagination.number) : 1;\n        pagination.start = pagination.start >= filtered.length ? (pagination.numberOfPages - 1) * pagination.number : pagination.start;\n        output = filtered.slice(pagination.start, pagination.start + parseInt(pagination.number));\n      }\n      displaySetter($scope, output || filtered);\n    };\n\n    /**\n     * select a dataRow (it will add the attribute isSelected to the row object)\n     * @param {Object} row - the row to select\n     * @param {String} [mode] - \"single\" or \"multiple\" (multiple by default)\n     */\n    this.select = function select (row, mode) {\n      var rows = copyRefs(displayGetter($scope));\n      var index = rows.indexOf(row);\n      if (index !== -1) {\n        if (mode === 'single') {\n          row.isSelected = row.isSelected !== true;\n          if (lastSelected) {\n            lastSelected.isSelected = false;\n          }\n          lastSelected = row.isSelected === true ? row : undefined;\n        } else {\n          rows[index].isSelected = !rows[index].isSelected;\n        }\n      }\n    };\n\n    /**\n     * take a slice of the current sorted/filtered collection (pagination)\n     *\n     * @param {Number} start - start index of the slice\n     * @param {Number} number - the number of item in the slice\n     */\n    this.slice = function splice (start, number) {\n      tableState.pagination.start = start;\n      tableState.pagination.number = number;\n      return this.pipe();\n    };\n\n    /**\n     * return the current state of the table\n     * @returns {{sort: {}, search: {}, pagination: {start: number}}}\n     */\n    this.tableState = function getTableState () {\n      return tableState;\n    };\n\n    this.getFilteredCollection = function getFilteredCollection () {\n      return filtered || safeCopy;\n    };\n\n    /**\n     * Use a different filter function than the angular FilterFilter\n     * @param filterName the name under which the custom filter is registered\n     */\n    this.setFilterFunction = function setFilterFunction (filterName) {\n      filter = $filter(filterName);\n    };\n\n    /**\n     * Use a different function than the angular orderBy\n     * @param sortFunctionName the name under which the custom order function is registered\n     */\n    this.setSortFunction = function setSortFunction (sortFunctionName) {\n      orderBy = $filter(sortFunctionName);\n    };\n\n    /**\n     * Usually when the safe copy is updated the pipe function is called.\n     * Calling this method will prevent it, which is something required when using a custom pipe function\n     */\n    this.preventPipeOnWatch = function preventPipe () {\n      pipeAfterSafeCopy = false;\n    };\n  }])\n  .directive('stTable', function () {\n    return {\n      restrict: 'A',\n      controller: 'stTableController',\n      link: function (scope, element, attr, ctrl) {\n\n        if (attr.stSetFilter) {\n          ctrl.setFilterFunction(attr.stSetFilter);\n        }\n\n        if (attr.stSetSort) {\n          ctrl.setSortFunction(attr.stSetSort);\n        }\n      }\n    };\n  });\n\nng.module('smart-table')\n  .directive('stSort', ['stConfig', '$parse', '$timeout', function (stConfig, $parse, $timeout) {\n    return {\n      restrict: 'A',\n      require: '^stTable',\n      link: function (scope, element, attr, ctrl) {\n\n        var predicate = attr.stSort;\n        var getter = $parse(predicate);\n        var index = 0;\n        var classAscent = attr.stClassAscent || stConfig.sort.ascentClass;\n        var classDescent = attr.stClassDescent || stConfig.sort.descentClass;\n        var stateClasses = [classAscent, classDescent];\n        var sortDefault;\n        var skipNatural = attr.stSkipNatural !== undefined ? attr.stSkipNatural : stConfig.sort.skipNatural;\n        var descendingFirst = attr.stDescendingFirst !== undefined ? attr.stDescendingFirst : stConfig.sort.descendingFirst;\n        var promise = null;\n        var throttle = attr.stDelay || stConfig.sort.delay;\n\n        if (attr.stSortDefault) {\n          sortDefault = scope.$eval(attr.stSortDefault) !== undefined ? scope.$eval(attr.stSortDefault) : attr.stSortDefault;\n        }\n\n        //view --> table state\n        function sort () {\n          if (descendingFirst) {\n            index = index === 0 ? 2 : index - 1;\n          } else {\n            index++;\n          }\n\n          var func;\n          predicate = ng.isFunction(getter(scope)) || ng.isArray(getter(scope)) ? getter(scope) : attr.stSort;\n          if (index % 3 === 0 && !!skipNatural !== true) {\n            //manual reset\n            index = 0;\n            ctrl.tableState().sort = {};\n            ctrl.tableState().pagination.start = 0;\n            func = ctrl.pipe.bind(ctrl);\n          } else {\n            func = ctrl.sortBy.bind(ctrl, predicate, index % 2 === 0);\n          }\n          if (promise !== null) {\n            $timeout.cancel(promise);\n          }\n          if (throttle < 0) {\n            func();\n          } else {\n            promise = $timeout(func, throttle);\n          }\n        }\n\n        element.bind('click', function sortClick () {\n          if (predicate) {\n            scope.$apply(sort);\n          }\n        });\n\n        if (sortDefault) {\n          index = sortDefault === 'reverse' ? 1 : 0;\n          sort();\n        }\n\n        //table state --> view\n        scope.$watch(function () {\n          return ctrl.tableState().sort;\n        }, function (newValue) {\n          if (newValue.predicate !== predicate) {\n            index = 0;\n            element\n              .removeClass(classAscent)\n              .removeClass(classDescent);\n          } else {\n            index = newValue.reverse === true ? 2 : 1;\n            element\n              .removeClass(stateClasses[index % 2])\n              .addClass(stateClasses[index - 1]);\n          }\n        }, true);\n      }\n    };\n  }]);\n\nng.module('smart-table')\r\n.directive('stSelectRowEx', ['stConfig', function(stConfig) {\r\n    return {\r\n        restrict: 'A',\r\n        require: '^stTable',\r\n        scope: {\r\n            row: '=stSelectRow',\r\n            rowsSelected: '=?stSelectRowsSelected',\r\n            enabled: '=?stSelectEnabled'\r\n        },\r\n        link: function(scope, element, attr, ctrl) {\r\n            var mode = attr.stSelectMode || stConfig.select.mode;\r\n            element.bind('click', function() {\r\n                scope.$apply(function() {\r\n                    if (scope.enabled === false)\r\n                        return;\r\n                    ctrl.select(scope.row, mode);\r\n                });\r\n            });\r\n\r\n            scope.$watch('row.isSelected', function(newValue) {\r\n                if (newValue === true) {\r\n                    element.addClass(stConfig.select.selectedClass);\r\n                    scope.rowsSelected && scope.rowsSelected.push(scope.row);\r\n                } else {\r\n                    element.removeClass(stConfig.select.selectedClass);\r\n                    //Care for IE8, it doesn't support indexOf. One possible solution can be define it in the Array prototype so it will be available in ie8 \r\n                    scope.rowsSelected && scope.rowsSelected.indexOf(scope.row) !== -1 && scope.rowsSelected.splice(scope.rowsSelected.indexOf(scope.row), 1);\r\n                }\r\n            });\r\n\r\n            scope.$watch('enabled', function(newValue) {\r\n                if (newValue === false)\r\n                    scope.row.isSelected = false;\r\n            });\r\n\r\n        }\r\n    };\r\n}]);\n})(angular);"],"sourceRoot":"/source/"}